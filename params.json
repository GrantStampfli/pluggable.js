{
  "name": "pluggable.js",
  "tagline": "Lets you make your JS code pluggable while still keeping sensitive objects and data private through closures.",
  "body": "        ____  __                        __    __         _\r\n       / __ \\/ /_  __ ___   ___  ____ _/ /_  / /__      (_)____\r\n      / /_/ / / / / / __ \\/ __ \\/ __/ / __ \\/ / _ \\    / / ___/\r\n     / ____/ / /_/ / /_/ / /_/ / /_/ / /_/ / /  __/   / (__  )\r\n    /_/   /_/\\__,_/\\__, /\\__, /\\__/_/_.___/_/\\___(_)_/ /____/\r\n                  /____//____/                    /___/ \r\n\r\n# Introduction\r\n\r\npluggable.js lets you make your JS code pluggable while still\r\nkeeping sensitive objects and data private through closures.\r\n\r\nIt was originally written for [converse.js](https://conversejs.org), to provide\r\na plugin architecture that allows 3rd party developers to extend and override\r\nprivate [backbone.js](http://backbonejs.org) classes, but it does not require\r\nnor depend on either library.\r\n\r\n# Documentation\r\n\r\nTo understand how it works under the hood, read the [annotated source code](\r\nhttps://jcbrand.github.io/pluggable.js/docs/pluggable.html).\r\n\r\nThe usage documentation follows below. There's also a [live demo](https://jcbrand.github.io/pluggable.js/examples/)\r\nof the example below.\r\n\r\n## Usage\r\n\r\nSuppose you have the following module, containing a private method (for\r\nwhatever reason) `showNotification` which you'd like to make overridable:\r\n\r\n``` Javascript\r\n    (function () {\r\n        var _private = {\r\n            showNotification: function (title, text) {\r\n                var n = new Notification(title, { body: text });\r\n                setTimeout(n.close.bind(n), 5000);\r\n            }\r\n        };\r\n\r\n        pluggable.enable(_private);\r\n        _private.pluggable.initializePlugins();\r\n\r\n        var _public = {\r\n            'registerPlugin': _private.pluggable.register\r\n        }\r\n        window.myApp = _public;\r\n    })();\r\n```\r\n\r\n### Overrides\r\n\r\nPrivate (closured) objects can be overridden or modified by plugins. When multiple\r\nplugins override a method of a private object, then a method call can travel up\r\nthrough all the overrides all the way to the original overridden method.\r\n\r\nThis is possible because pluggable.js enables the calling of a super method\r\nthrough the `_super` attribute.\r\n\r\nFor example, imagine we have an object being overridden which has a method\r\n`showNotification`. In our override we want to also play a sound, and then call\r\nthe original method so that the notification is displayed.\r\n\r\nHere's what that would look like:\r\n\r\n``` Javascript\r\n    window.myapp.registerplugin('my-plugin', {\r\n\r\n        overrides: {\r\n            // overrides mentioned here will be picked up by Pluggable's\r\n            // plugin architecture, they will replace existing methods on the\r\n            // relevant objects or classes.\r\n            // \r\n            // When overriding a method or function, you can still call the\r\n            // original as an attribute on `this._super`. To properly call it\r\n            // as if it was never overridden, you can call it with\r\n            // `.apply(this, arguments)`.\r\n            //\r\n            // New functions which don't exist yet can also be added.\r\n\r\n            playSound: function () {\r\n                // Please imagine there's code to play a sound here...\r\n                // This method doesn't exist on the original object being\r\n                // overriden here.\r\n            },\r\n\r\n            showNotification: function () {\r\n                /* Override showNotification to also play a sound\r\n                 */\r\n                playSound();\r\n                // Call the super method so that the notification is also shown.\r\n                this._super.showNotification.applyt(this, arguments);\r\n            }\r\n        }\r\n    });\r\n```\r\n\r\n### Custom plugin code\r\n\r\nBesides overriding private objects and methods, plugins might also want to\r\ncreate their own objects and functions independent of the overridden object but\r\nstill having access to it.\r\n\r\nFor that, there is the `initialize` method, which if available on the plugin,\r\nwill be called once the closured object calls `initializePlugins`.\r\n\r\n``` Javascript\r\n    myapp.registerplugin('my-plugin', {\r\n\r\n        overrides: {\r\n            /* Code here truncated for brevity, to see what would go here,\r\n             * refer to the example above.\r\n             */\r\n        },\r\n\r\n        initialize: function () {\r\n            // The initialize function gets called as soon as the plugin is\r\n            // loaded by pluggable.js's plugin machinery.\r\n\r\n        }\r\n    });\r\n```\r\n",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}